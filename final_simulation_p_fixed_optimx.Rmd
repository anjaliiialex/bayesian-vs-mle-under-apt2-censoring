---
title: "final simulation fixing p and using optimx
date: "2025-08-15"
output: html_document
---

### 1. Load libraries
```{r setup, message=FALSE, warning=FALSE}
library(rjags)
library(coda)
library(actuar) 
library(VGAM)
library(optimx)
```

### 2. Define MLE function
```{r}
negloglik_dagum_p_fixed <- function(par, data, p_fixed) {
  a <- par[1]
  b <- par[2]
  if (a <= 0 || b <= 0 || !is.finite(a) || !is.finite(b)) return(1e20) # Return a large number for bad pars
  -sum(actuar::ddagum(x = data, shape1.a = a, scale = b, shape2.p = p_fixed, log = TRUE, .is.sorted = TRUE))
}
```

### 3. Simulation Settings
```{r}
n_sim <- 100
n_total <- 100
r <- 60
true_a <- 2.5
true_b <- 1.5
true_p <- 1.2
```

### 4. Setup Storage
```{r}
mle_results <- matrix(NA, nrow = n_sim, ncol = 3)
bayes_results <- matrix(NA, nrow = n_sim, ncol = 3)
colnames(mle_results) <- colnames(bayes_results) <- c("a", "b", "p")
```

### 5. Simulation Loop
```{r}
for (sim in 1:n_sim) {
  cat("Running simulation:", sim, "/", n_sim, "\n")
  set.seed(100 + sim)
  
  y_full <- sort(VGAM::rdagum(n = n_total, scale = true_b, shape1.a = true_a, shape2.p = true_p))
  failures <- y_full[1:r]
  y <- ifelse(failures <= 0, 1e-6, failures)
  N <- length(y)

  # --- MLE Estimation using optimx ---
  # This section is now standalone and does not depend on the Bayesian results.
  mle_fit_results <- try(optimx(
      par = c(2, 2), # Using the fixed, naive starting point
      fn = negloglik_dagum_p_fixed,
      data = y,
      p_fixed = true_p,
      method = c("nlminb", "L-BFGS-B"), # Try two powerful methods
      lower = c(1e-5, 1e-5)
  ), silent = TRUE)
  
  if (!inherits(mle_fit_results, "try-error")) {
    # 1. Filter for optimizers that converged successfully (convcode == 0)
    successful_runs <- subset(mle_fit_results, convcode == 0)
    
    # 2. If at least one optimizer succeeded, find the best one
    if (nrow(successful_runs) > 0) {
      # The "best" is the one with the lowest function value (min neg-log-lik)
      best_run <- successful_runs[which.min(successful_runs$value), ]
      
      # 3. Extract the parameters (p1 is the first param, p2 is the second)
      mle_results[sim, ] <- c(best_run$p1, best_run$p2, true_p)
    }
  }

  # --- Bayesian Estimation ---
  # This part remains the same
  jags_data <- list(y = y, N = N, p = true_p, zeros = rep(0, N))
  post_means <- try({
    model <- jags.model("dagum_model_p_fixed.txt", data = jags_data, n.chains = 2, n.adapt = 2000, quiet = TRUE)
    update(model, 2000)
    samples <- coda.samples(model, variable.names = c("a", "b"), n.iter = 5000)
    colMeans(as.matrix(samples))
  }, silent = TRUE)
  
  if (!inherits(post_means, "try-error")) {
    bayes_results[sim, ] <- c(post_means, true_p)
  }
}
```

### 6. Calculation and Printing of Results
```{r}
mle_results_clean <- na.omit(mle_results)
bayes_results_clean <- na.omit(bayes_results)

cat("\nNumber of successful MLE fits:", nrow(mle_results_clean), "/", n_sim, "\n")
cat("Number of successful Bayes fits:", nrow(bayes_results_clean), "/", n_sim, "\n\n")

compute_bias_mse <- function(estimates, true_vals) {
  bias <- colMeans(estimates) - true_vals
  mse <- colMeans((t(t(estimates) - true_vals))^2)
  return(list(bias = bias, mse = mse))
}

true_vals <- c("a" = true_a, "b" = true_b, "p" = true_p)

# We only calculate bias/mse for the estimated parameters 'a' and 'b'
mle_metrics <- compute_bias_mse(mle_results_clean[, 1:2], true_vals[1:2])
bayes_metrics <- compute_bias_mse(bayes_results_clean[, 1:2], true_vals[1:2])

cat("== Bias (for a, b) ==\nMLE:\n"); print(mle_metrics$bias)
cat("\nBayesian:\n"); print(bayes_metrics$bias)
cat("\n== MSE (for a, b) ==\nMLE:\n"); print(mle_metrics$mse)
cat("\nBayesian:\n"); print(bayes_metrics$mse)
```

