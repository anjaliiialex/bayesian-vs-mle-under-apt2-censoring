---
title: "fixed simulation w rstan"
author: "Anjali Alex"
date: "2025-09-21"
output: html_document
---

```{r}
### 1. Load Libraries
library(future)
library(future.apply)
library(rstan)
library(VGAM)
library(optimx)

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
### 2. Pre-compile the Stan Model
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cat("Pre-compiling the Stan model... (This may take a minute)\n")
stan_model_compiled <- rstan::stan_model("dagum_model_progressive_fixed.stan")
cat("...Stan model compiled.\n")

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
### 3. Define Helper & Main Simulation Functions
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Log-likelihood for PROGRESSIVE censoring
negloglik_dagum_progressive_censored <- function(par, data, R, p_fixed) {
  a <- par[1]; b <- par[2]
  if (a <= 0 || b <= 0 || !is.finite(a) || !is.finite(b)) return(1e20)
  
  # Log-likelihood from the r observed failures
  loglik_failures <- sum(VGAM::ddagum(x = data, scale = b, shape1.a = a, shape2.p = p_fixed, log = TRUE))
  
  # Log-likelihood from the progressively removed units
  loglik_censored <- sum(R * VGAM::pdagum(q = data, scale = b, shape1.a = a, shape2.p = p_fixed, lower.tail = FALSE, log.p = TRUE))
  
  -1 * (loglik_failures + loglik_censored)
}

run_one_simulation <- function(sim_id, n_total, r, R_planned, T_ideal, true_a, true_b, true_p, compiled_model) {
  
  set.seed(100 + sim_id)
  
  # --- ADAPTIVE PROGRESSIVE CENSORING SIMULATION ---
  y_full <- sort(VGAM::rdagum(n = n_total, scale = true_b, shape1.a = true_a, shape2.p = true_p))
  
  y_obs <- numeric(r)
  R_final <- R_planned
  
  current_n <- n_total
  full_data_idx <- 1
  adapted <- FALSE
  
  for (i in 1:r) {
    y_obs[i] <- y_full[full_data_idx]
    
    if (!adapted && y_obs[i] > T_ideal) {
      adapted <- TRUE
      removed_so_far <- if (i > 1) sum(R_final[1:(i-1)]) else 0
      if (i < r) {
        R_final[(i):r] <- 0
      }
      R_final[r] <- n_total - r - removed_so_far
    }
    
    n_removed_this_step <- 1 + R_final[i]
    full_data_idx <- full_data_idx + n_removed_this_step
    current_n <- current_n - n_removed_this_step
  }
  
  y <- ifelse(y_obs <= 0, 1e-6, y_obs)
  N <- length(y)
  
  results <- data.frame(mle_a=NA, mle_b=NA, bayes_a=NA, bayes_b=NA,
                        mle_cov_a=NA, mle_cov_b=NA, bayes_cov_a=NA, bayes_cov_b=NA,
                        mle_width_a=NA, mle_width_b=NA, bayes_width_a=NA, bayes_width_b=NA,
                        mle_time=NA, bayes_time=NA, adapted=adapted, divergences=NA,
                        valid_bayes=FALSE)

  # --- Bayesian Estimation using the pre-compiled Stan model ---
  bayes_start_time <- Sys.time()
  stan_data <- list(N_obs = N, y_obs = y, R = R_final, p = true_p)
  
  stan_fit <- try(rstan::sampling(object = compiled_model,
                                  data = stan_data,
                                  chains = 4, iter = 3000, warmup = 1500,  # Increased
                                  verbose = FALSE, refresh = 0,
                                  control = list(adapt_delta = 0.98, max_treedepth = 12)), silent = TRUE)
  
  results$bayes_time <- as.numeric(difftime(Sys.time(), bayes_start_time, units="secs"))
  
  if (!inherits(stan_fit, "try-error")) {
    
    # Check for divergences
    sampler_params <- get_sampler_params(stan_fit, inc_warmup = FALSE)
    divergences <- sum(sapply(sampler_params, function(x) sum(x[, "divergent__"])))
    results$divergences <- divergences
    
    if (divergences > 0) {
        cat(paste("Warning: Simulation", sim_id, "had", divergences, "divergent transitions.\n"))
    }
    
    summary_stats <- rstan::summary(stan_fit)$summary
    rhats <- summary_stats[, "Rhat"]
    
    # ONLY use results if no divergences AND good Rhat values
    if (all(rhats < 1.1, na.rm = TRUE) && divergences == 0) {
        results$valid_bayes <- TRUE
        results$bayes_a <- mean(as.matrix(stan_fit)[,"a"])
        results$bayes_b <- mean(as.matrix(stan_fit)[,"b"])
        cred_intervals <- summary_stats[c("a","b"), c("2.5%", "97.5%")]
        results$bayes_width_a <- cred_intervals["a","97.5%"] - cred_intervals["a","2.5%"]
        results$bayes_width_b <- cred_intervals["b","97.5%"] - cred_intervals["b","2.5%"]
        results$bayes_cov_a <- (true_a > cred_intervals["a","2.5%"] && true_a < cred_intervals["a","97.5%"])
        # FIXED THE BUG HERE:
        results$bayes_cov_b <- (true_b > cred_intervals["b","2.5%"] && true_b < cred_intervals["b","97.5%"])
    }
  }

  # --- MLE Estimation with FAIR starting values ---
  mle_start_time <- Sys.time()
  # Use generic starting values, not based on true parameters
  start_par <- c(1.0, 1.0)  # Fair starting values
  
  mle_fit <- try(optimx::optimx(par=start_par, fn=negloglik_dagum_progressive_censored, 
                                data=y, R=R_final, p_fixed=true_p,
                                method="nlminb", lower=c(1e-5, 1e-5), hessian=TRUE), silent=TRUE)
  results$mle_time <- as.numeric(difftime(Sys.time(), mle_start_time, units="secs"))
  
  if (!inherits(mle_fit, "try-error") && mle_fit$convcode == 0) {
    results$mle_a <- mle_fit$p1
    results$mle_b <- mle_fit$p2
    hessian_matrix <- attr(mle_fit, "details")[["nlminb", "nhatend"]]
      if (!is.null(hessian_matrix) && is.matrix(hessian_matrix)) {
        fisher_info <- try(solve(hessian_matrix), silent=TRUE)
        if (!inherits(fisher_info, "try-error") && all(diag(fisher_info) > 0)) {
          std_errors <- sqrt(diag(fisher_info))
          ci_a <- results$mle_a + c(-1,1) * 1.96 * std_errors[1]
          ci_b <- results$mle_b + c(-1,1) * 1.96 * std_errors[2]
          results$mle_width_a <- ci_a[2] - ci_a[1]
          results$mle_width_b <- ci_b[2] - ci_b[1]
          results$mle_cov_a <- (true_a > ci_a[1] && true_a < ci_a[2])
          results$mle_cov_b <- (true_b > ci_b[1] && true_b < ci_b[2])
        }
      }
  }
  return(results)
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
### 4. Main Script to Run Simulation
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
n_sim <- 1000  
n_total <- 100
r <- 60
true_a <- 2.5
true_b <- 1.5
true_p <- 1.2

T_ideal <- 2.0 
R_planned <- c(rep(0, r - 1), n_total - r) 

plan(multisession)

cat("Starting", n_sim, "simulations in parallel...\n")
start_time <- Sys.time()

results_list <- future_lapply(1:n_sim, FUN = run_one_simulation,
                              n_total=n_total, r=r, R_planned=R_planned, T_ideal=T_ideal,
                              true_a=true_a, true_b=true_b, true_p=true_p,
                              compiled_model = stan_model_compiled,
                              future.seed = TRUE)

end_time <- Sys.time()
cat("...simulations complete. Total time:", round(end_time - start_time, 2), "seconds\n")

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
### 5. Process and Summarize Results (Only valid Bayesian runs)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
final_results_df <- do.call(rbind, results_list)

# Filter to only valid Bayesian results for fair comparison
valid_results <- final_results_df[final_results_df$valid_bayes == TRUE, ]

cat(sprintf("Valid Bayesian results: %d out of %d (%.1f%%)\n", 
            nrow(valid_results), nrow(final_results_df), 
            100 * nrow(valid_results) / nrow(final_results_df)))

summary_a <- data.frame(
  Metric = c("Bias", "MSE", "Coverage", "Width"),
  MLE    = c(mean(valid_results$mle_a - true_a, na.rm=TRUE),
             mean((valid_results$mle_a - true_a)^2, na.rm=TRUE),
             mean(valid_results$mle_cov_a, na.rm=TRUE),
             mean(valid_results$mle_width_a, na.rm=TRUE)),
  Bayes  = c(mean(valid_results$bayes_a - true_a, na.rm=TRUE),
             mean((valid_results$bayes_a - true_a)^2, na.rm=TRUE),
             mean(valid_results$bayes_cov_a, na.rm=TRUE),
             mean(valid_results$bayes_width_a, na.rm=TRUE))
)

summary_b <- data.frame(
  Metric = c("Bias", "MSE", "Coverage", "Width"),
  MLE    = c(mean(valid_results$mle_b - true_b, na.rm=TRUE),
             mean((valid_results$mle_b - true_b)^2, na.rm=TRUE),
             mean(valid_results$mle_cov_b, na.rm=TRUE),
             mean(valid_results$mle_width_b, na.rm=TRUE)),
  Bayes  = c(mean(valid_results$bayes_b - true_b, na.rm=TRUE),
             mean((valid_results$bayes_b - true_b)^2, na.rm=TRUE),
             mean(valid_results$bayes_cov_b, na.rm=TRUE),
             mean(valid_results$bayes_width_b, na.rm=TRUE))
)

avg_times <- data.frame(
  Method = c("MLE Time", "Bayes Time"),
  Seconds = c(mean(valid_results$mle_time, na.rm=TRUE),
              mean(valid_results$bayes_time, na.rm=TRUE))
)

cat("\n--- Summary Results for Parameter 'a' ---\n")
print(summary_a, row.names=FALSE)
cat("\n--- Summary Results for Parameter 'b' ---\n")
print(summary_b, row.names=FALSE)
cat("\n--- Average Computation Time ---\n")
print(avg_times, row.names=FALSE)
cat("\n--- Adaptive Scheme Trigger Summary ---\n")
cat(sprintf("The censoring scheme was adapted in %.2f%% of simulations.\n", 
            mean(final_results_df$adapted, na.rm=TRUE) * 100))

# Additional diagnostics
cat("\n--- Divergence Summary ---\n")
cat(sprintf("Total divergent transitions: %d\n", sum(final_results_df$divergences, na.rm=TRUE)))
cat(sprintf("Simulations with divergences: %d (%.1f%%)\n", 
            sum(final_results_df$divergences > 0, na.rm=TRUE),
            100 * mean(final_results_df$divergences > 0, na.rm=TRUE)))
```

### final
```{r}
### FINAL WORKING VERSION - All Issues Fixed
library(future)
library(future.apply)
library(rstan)
library(VGAM)
library(optimx)

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
### 1. Pre-compile the Stan Model
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Create the corrected Stan model
stan_model_code <- '
functions {
  real dagum_lpdf(real y, real a, real b, real p) {
    if (y <= 0) {
      return negative_infinity();
    }
    
    real log_y = log(y);
    real log_b = log(b);
    real log_ratio = -p * (log_y - log_b);
    
    real log_1_plus_ratio;
    if (log_ratio > 20) {
      log_1_plus_ratio = log_ratio;
    } else {
      log_1_plus_ratio = log1p_exp(log_ratio);
    }
    
    return log(a) + log(p) - (p + 1) * log_y - (a + 1) * log_1_plus_ratio + p * log_b;
  }
  
  real dagum_lccdf(real y, real a, real b, real p) {
    if (y <= 0) {
      return 0;
    }
    
    real log_y = log(y);
    real log_b = log(b);
    real log_ratio = -p * (log_y - log_b);
    
    real log_1_plus_ratio;
    if (log_ratio > 20) {
      log_1_plus_ratio = log_ratio;
    } else {
      log_1_plus_ratio = log1p_exp(log_ratio);
    }
    
    return -a * log_1_plus_ratio;
  }
}

data {
  int<lower=0> N_obs;      
  vector<lower=0>[N_obs] y_obs; 
  int<lower=0> R[N_obs];   
  real<lower=0> p;         
}

parameters {
  real log_a;
  real log_b;
}

transformed parameters {
  real<lower=0> a = exp(log_a);
  real<lower=0> b = exp(log_b);
}

model {
  // Proper uninformative priors
  log_a ~ normal(0, 1.5);
  log_b ~ normal(0, 1.5);
  
  // Likelihood for observed failures
  for (i in 1:N_obs) {
    target += dagum_lpdf(y_obs[i] | a, b, p);
  }
  
  // Likelihood for progressively censored units
  for (i in 1:N_obs) {
    if (R[i] > 0) {
      target += R[i] * dagum_lccdf(y_obs[i] | a, b, p);
    }
  }
}
'

# Write and compile the model
writeLines(stan_model_code, "dagum_model_fixed.stan")
cat("Compiling Stan model...\n")
stan_model_compiled <- rstan::stan_model("dagum_model_fixed.stan")
cat("Stan model compiled successfully!\n\n")

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
### 2. Define Corrected Likelihood Function
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# CORRECTED likelihood function - THE KEY FIX
negloglik_dagum_progressive_censored <- function(par, data, R, p_fixed) {
  a <- par[1]; b <- par[2]
  if (a <= 0 || b <= 0 || !is.finite(a) || !is.finite(b)) return(1e20)
  
  # KEY FIX: Use ddagum WITHOUT VGAM:: prefix
  loglik_failures <- sum(log(ddagum(data, a, b, p_fixed)))
  
  # Use VGAM::pdagum (this works correctly)
  survival_probs <- 1 - VGAM::pdagum(q = data, scale = b, shape1.a = a, shape2.p = p_fixed)
  loglik_censored <- sum(R * log(survival_probs))
  
  -1 * (loglik_failures + loglik_censored)
}

# Quick test of the fixed function
cat("Testing corrected likelihood function...\n")
test_y <- c(0.5, 1.0, 1.5, 2.0, 3.0)
test_R <- c(0, 0, 2, 0, 5)
test_result <- negloglik_dagum_progressive_censored(c(2.5, 1.5), test_y, test_R, 1.2)
cat("Test result:", test_result, "(should be around 16.86)\n\n")

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
### 3. Main Simulation Function
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

run_one_simulation <- function(sim_id, n_total, r, R_planned, T_ideal, true_a, true_b, true_p, compiled_model) {
  
  set.seed(100 + sim_id)
  
  # Generate Dagum data
  y_full <- sort(VGAM::rdagum(n = n_total, scale = true_b, shape1.a = true_a, shape2.p = true_p))
  
  y_obs <- numeric(r)
  R_final <- R_planned
  
  current_n <- n_total
  full_data_idx <- 1
  adapted <- FALSE
  
  # Adaptive progressive censoring
  for (i in 1:r) {
    y_obs[i] <- y_full[full_data_idx]
    
    if (!adapted && y_obs[i] > T_ideal) {
      adapted <- TRUE
      removed_so_far <- if (i > 1) sum(R_final[1:(i-1)]) else 0
      if (i < r) {
        R_final[(i):r] <- 0
      }
      R_final[r] <- n_total - r - removed_so_far
    }
    
    n_removed_this_step <- 1 + R_final[i]
    full_data_idx <- full_data_idx + n_removed_this_step
    current_n <- current_n - n_removed_this_step
  }
  
  y <- ifelse(y_obs <= 0, 1e-6, y_obs)
  N <- length(y)
  
  results <- data.frame(mle_a=NA, mle_b=NA, bayes_a=NA, bayes_b=NA,
                        mle_cov_a=NA, mle_cov_b=NA, bayes_cov_a=NA, bayes_cov_b=NA,
                        mle_width_a=NA, mle_width_b=NA, bayes_width_a=NA, bayes_width_b=NA,
                        mle_time=NA, bayes_time=NA, adapted=adapted, divergences=NA,
                        valid_bayes=FALSE)

  # --- Bayesian Estimation ---
  bayes_start_time <- Sys.time()
  stan_data <- list(N_obs = N, y_obs = y, R = R_final, p = true_p)
  
  stan_fit <- try(rstan::sampling(object = compiled_model,
                                  data = stan_data,
                                  chains = 4, iter = 2000, warmup = 1000,
                                  verbose = FALSE, refresh = 0,
                                  control = list(adapt_delta = 0.95, max_treedepth = 10)), silent = TRUE)
  
  results$bayes_time <- as.numeric(difftime(Sys.time(), bayes_start_time, units="secs"))
  
  if (!inherits(stan_fit, "try-error")) {
    
    # Check for divergences
    sampler_params <- get_sampler_params(stan_fit, inc_warmup = FALSE)
    divergences <- sum(sapply(sampler_params, function(x) sum(x[, "divergent__"])))
    results$divergences <- divergences
    
    if (divergences > 0) {
        cat(paste("Simulation", sim_id, "had", divergences, "divergent transitions.\n"))
    }
    
    summary_stats <- rstan::summary(stan_fit)$summary
    rhats <- summary_stats[, "Rhat"]
    
    # Only use results if good convergence and few divergences
    if (all(rhats < 1.1, na.rm = TRUE) && divergences <= 10) {
        results$valid_bayes <- TRUE
        results$bayes_a <- mean(as.matrix(stan_fit)[,"a"])
        results$bayes_b <- mean(as.matrix(stan_fit)[,"b"])
        cred_intervals <- summary_stats[c("a","b"), c("2.5%", "97.5%")]
        results$bayes_width_a <- cred_intervals["a","97.5%"] - cred_intervals["a","2.5%"]
        results$bayes_width_b <- cred_intervals["b","97.5%"] - cred_intervals["b","2.5%"]
        results$bayes_cov_a <- (true_a > cred_intervals["a","2.5%"] && true_a < cred_intervals["a","97.5%"])
        # FIXED THE BUG: Use 97.5% instead of 2.5% twice
        results$bayes_cov_b <- (true_b > cred_intervals["b","2.5%"] && true_b < cred_intervals["b","97.5%"])
    }
  }

  # --- MLE Estimation with fair starting values ---
  mle_start_time <- Sys.time()
  start_par <- c(1.0, 1.0)  # Fair starting values, not based on true parameters
  
  mle_fit <- try(optimx::optimx(par=start_par, fn=negloglik_dagum_progressive_censored, 
                                data=y, R=R_final, p_fixed=true_p,
                                method="nlminb", lower=c(1e-5, 1e-5), hessian=TRUE), silent=TRUE)
  results$mle_time <- as.numeric(difftime(Sys.time(), mle_start_time, units="secs"))
  
  if (!inherits(mle_fit, "try-error") && mle_fit$convcode == 0) {
    results$mle_a <- mle_fit$p1
    results$mle_b <- mle_fit$p2
    hessian_matrix <- attr(mle_fit, "details")[["nlminb", "nhatend"]]
      if (!is.null(hessian_matrix) && is.matrix(hessian_matrix)) {
        fisher_info <- try(solve(hessian_matrix), silent=TRUE)
        if (!inherits(fisher_info, "try-error") && all(diag(fisher_info) > 0)) {
          std_errors <- sqrt(diag(fisher_info))
          ci_a <- results$mle_a + c(-1,1) * 1.96 * std_errors[1]
          ci_b <- results$mle_b + c(-1,1) * 1.96 * std_errors[2]
          results$mle_width_a <- ci_a[2] - ci_a[1]
          results$mle_width_b <- ci_b[2] - ci_b[1]
          results$mle_cov_a <- (true_a > ci_a[1] && true_a < ci_a[2])
          results$mle_cov_b <- (true_b > ci_b[1] && true_b < ci_b[2])
        }
      }
  }
  return(results)
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
### 4. Run Simulation
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Parameters
n_sim <- 100  # Start with 100 simulations for testing
n_total <- 100
r <- 60
true_a <- 2.5
true_b <- 1.5
true_p <- 1.2

T_ideal <- 2.0 
R_planned <- c(rep(0, r - 1), n_total - r) 

plan(multisession)

cat("Starting", n_sim, "simulations...\n")
start_time <- Sys.time()

results_list <- future_lapply(1:n_sim, FUN = run_one_simulation,
                              n_total=n_total, r=r, R_planned=R_planned, T_ideal=T_ideal,
                              true_a=true_a, true_b=true_b, true_p=true_p,
                              compiled_model = stan_model_compiled,
                              future.seed = TRUE)

end_time <- Sys.time()
cat("Simulations complete. Time:", round(end_time - start_time, 2), "seconds\n")

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
### 5. Process Results
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

final_results_df <- do.call(rbind, results_list)
valid_results <- final_results_df[final_results_df$valid_bayes == TRUE, ]

cat(sprintf("\nValid Bayesian results: %d out of %d (%.1f%%)\n", 
            nrow(valid_results), nrow(final_results_df), 
            100 * nrow(valid_results) / nrow(final_results_df)))

if (nrow(valid_results) >= 20) {  # Need sufficient valid results
  
  summary_a <- data.frame(
    Metric = c("Bias", "MSE", "Coverage", "Width"),
    MLE    = c(mean(valid_results$mle_a - true_a, na.rm=TRUE),
               mean((valid_results$mle_a - true_a)^2, na.rm=TRUE),
               mean(valid_results$mle_cov_a, na.rm=TRUE),
               mean(valid_results$mle_width_a, na.rm=TRUE)),
    Bayes  = c(mean(valid_results$bayes_a - true_a, na.rm=TRUE),
               mean((valid_results$bayes_a - true_a)^2, na.rm=TRUE),
               mean(valid_results$bayes_cov_a, na.rm=TRUE),
               mean(valid_results$bayes_width_a, na.rm=TRUE))
  )

  summary_b <- data.frame(
    Metric = c("Bias", "MSE", "Coverage", "Width"),
    MLE    = c(mean(valid_results$mle_b - true_b, na.rm=TRUE),
               mean((valid_results$mle_b - true_b)^2, na.rm=TRUE),
               mean(valid_results$mle_cov_b, na.rm=TRUE),
               mean(valid_results$mle_width_b, na.rm=TRUE)),
    Bayes  = c(mean(valid_results$bayes_b - true_b, na.rm=TRUE),
               mean((valid_results$bayes_b - true_b)^2, na.rm=TRUE),
               mean(valid_results$bayes_cov_b, na.rm=TRUE),
               mean(valid_results$bayes_width_b, na.rm=TRUE))
  )

  cat("\n=== FINAL RESULTS ===\n")
  cat("--- Parameter 'a' ---\n")
  print(summary_a, row.names=FALSE)
  cat("\n--- Parameter 'b' ---\n")
  print(summary_b, row.names=FALSE)
  
  cat("\n--- Performance Comparison ---\n")
  cat("Bayesian is better than MLE in:\n")
  if (summary_a$Bayes[2] < summary_a$MLE[2]) cat("- MSE for parameter 'a'\n")
  if (summary_b$Bayes[2] < summary_b$MLE[2]) cat("- MSE for parameter 'b'\n")
  if (summary_a$Bayes[3] > summary_a$MLE[3]) cat("- Coverage for parameter 'a'\n")
  if (summary_b$Bayes[3] > summary_b$MLE[3]) cat("- Coverage for parameter 'b'\n")
  
  cat("\n--- Diagnostics ---\n")
  cat(sprintf("Total divergences: %d\n", sum(final_results_df$divergences, na.rm=TRUE)))
  cat(sprintf("Adaptations triggered: %.1f%%\n", 100 * mean(final_results_df$adapted, na.rm=TRUE)))
  
} else {
  cat("ERROR: Too few valid results. Need to adjust Stan model or parameters.\n")
}

cat("\n=== SIMULATION COMPLETE ===\n")
cat("If results look good, increase n_sim to 1000 for final analysis.\n")
```

```{r}
# Investigate what's happening with ddagum functions
library(VGAM)

cat("=== INVESTIGATING DDAGUM FUNCTIONS ===\n")

# Check what packages are loaded
cat("Loaded packages with 'dagum' functions:\n")
search_results <- apropos("ddagum")
print(search_results)

# Check which function is being called
cat("\nChecking function environments:\n")
cat("ddagum environment:", environmentName(environment(ddagum)), "\n")
cat("VGAM::ddagum environment:", environmentName(environment(VGAM::ddagum)), "\n")

# Check if they are the same function
cat("Are they identical functions?", identical(ddagum, VGAM::ddagum), "\n")

# Check their arguments
cat("\nFunction arguments:\n")
cat("ddagum args:", paste(names(formals(ddagum)), collapse = ", "), "\n")
cat("VGAM::ddagum args:", paste(names(formals(VGAM::ddagum)), collapse = ", "), "\n")

# Check function bodies (first few lines)
cat("\nChecking function signatures:\n")
cat("ddagum function class:", class(ddagum), "\n")
cat("VGAM::ddagum function class:", class(VGAM::ddagum), "\n")

# Test with explicit function calls
y_test <- c(0.5, 1.0, 1.5, 2.0, 3.0)
a_test <- 2.5
b_test <- 1.5  
p_test <- 1.2

cat("\n=== TESTING CORRECTED LIKELIHOOD FUNCTION ===\n")

# CORRECTED likelihood function using ddagum (without VGAM::)
negloglik_dagum_corrected_final <- function(par, data, R, p_fixed) {
  a <- par[1]; b <- par[2]
  if (a <= 0 || b <= 0 || !is.finite(a) || !is.finite(b)) return(1e20)
  
  # Use ddagum WITHOUT VGAM:: prefix
  loglik_failures <- sum(log(ddagum(data, a, b, p_fixed)))
  
  # Use pdagum with VGAM:: (this one works correctly)
  survival_probs <- 1 - VGAM::pdagum(q = data, scale = b, shape1.a = a, shape2.p = p_fixed)
  loglik_censored <- sum(R * log(survival_probs))
  
  -1 * (loglik_failures + loglik_censored)
}

# Test the corrected function
R_test <- c(0, 0, 2, 0, 5)
cat("Testing corrected likelihood function:\n")
corrected_result <- negloglik_dagum_corrected_final(c(a_test, b_test), y_test, R_test, p_test)
cat("Corrected negative log-likelihood:", corrected_result, "\n")

# Manual verification
manual_pdf <- ddagum(y_test, a_test, b_test, p_test)
manual_survival <- 1 - VGAM::pdagum(q = y_test, scale = b_test, shape1.a = a_test, shape2.p = p_test)
manual_result <- -(sum(log(manual_pdf)) + sum(R_test * log(manual_survival)))
cat("Manual calculation:", manual_result, "\n")
cat("Match:", abs(corrected_result - manual_result) < 1e-10, "\n")

# Also test pdagum with and without VGAM::
cat("\n=== TESTING PDAGUM FUNCTIONS ===\n")
cat("Testing pdagum vs VGAM::pdagum:\n")

# Test if there's a similar issue with pdagum
try({
  cdf_generic <- pdagum(q = y_test, scale = b_test, shape1.a = a_test, shape2.p = p_test)
  cat("pdagum result:", cdf_generic, "\n")
}, silent = FALSE)

try({
  cdf_vgam <- VGAM::pdagum(q = y_test, scale = b_test, shape1.a = a_test, shape2.p = p_test)
  cat("VGAM::pdagum result:", cdf_vgam, "\n")
}, silent = FALSE)

cat("\nIf the corrected function matches manual calculation, we've solved the problem!\n")
```

### no stan
```{r}
### R-based MCMC Implementation for Dagum Distribution
library(future)
library(future.apply)
library(VGAM)
library(optimx)
library(coda)  # For MCMC diagnostics

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
### 1. Corrected Likelihood Function (Already Working)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

negloglik_dagum_progressive_censored <- function(par, data, R, p_fixed) {
  a <- par[1]; b <- par[2]
  if (a <= 0 || b <= 0 || !is.finite(a) || !is.finite(b)) return(1e20)
  
  # Use ddagum without VGAM:: prefix (this works correctly)
  loglik_failures <- sum(log(ddagum(data, a, b, p_fixed)))
  
  # Use VGAM::pdagum for survival function
  survival_probs <- 1 - VGAM::pdagum(q = data, scale = b, shape1.a = a, shape2.p = p_fixed)
  loglik_censored <- sum(R * log(survival_probs))
  
  -1 * (loglik_failures + loglik_censored)
}

# Positive log-likelihood (for MCMC)
loglik_dagum_progressive <- function(par, data, R, p_fixed) {
  return(-negloglik_dagum_progressive_censored(par, data, R, p_fixed))
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
### 2. Prior Functions
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Log-prior function (uninformative priors)
log_prior <- function(par) {
  a <- par[1]; b <- par[2]
  if (a <= 0 || b <= 0) return(-Inf)
  
  # Uninformative priors: log(a) ~ N(0, 1.5^2), log(b) ~ N(0, 1.5^2)
  log_a <- log(a); log_b <- log(b)
  prior_log_a <- dnorm(log_a, mean = 0, sd = 1.5, log = TRUE)
  prior_log_b <- dnorm(log_b, mean = 0, sd = 1.5, log = TRUE)
  
  # Jacobian adjustment for log-transformation
  jacobian <- log_a + log_b  # |J| = a * b, so log|J| = log(a) + log(b)
  
  return(prior_log_a + prior_log_b + jacobian)
}

# Log-posterior function
log_posterior <- function(par, data, R, p_fixed) {
  lp <- log_prior(par)
  if (!is.finite(lp)) return(-Inf)
  
  ll <- loglik_dagum_progressive(par, data, R, p_fixed)
  if (!is.finite(ll)) return(-Inf)
  
  return(lp + ll)
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
### 3. Metropolis-Hastings MCMC Implementation
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

mcmc_dagum <- function(data, R, p_fixed, n_iter = 5000, n_burn = 1000, 
                       initial_par = c(1, 1), proposal_sd = c(0.1, 0.1)) {
  
  n_total <- n_iter + n_burn
  n_par <- length(initial_par)
  
  # Storage
  samples <- matrix(NA, n_total, n_par)
  log_post_vals <- numeric(n_total)
  accepted <- numeric(n_total)
  
  # Initialize
  current_par <- initial_par
  current_log_post <- log_posterior(current_par, data, R, p_fixed)
  
  if (!is.finite(current_log_post)) {
    # Try to find better starting values
    mle_fit <- try(optimx(par = initial_par, 
                          fn = negloglik_dagum_progressive_censored,
                          data = data, R = R, p_fixed = p_fixed,
                          method = "nlminb", lower = c(1e-5, 1e-5)), silent = TRUE)
    
    if (!inherits(mle_fit, "try-error") && mle_fit$convcode == 0) {
      current_par <- c(mle_fit$p1, mle_fit$p2)
      current_log_post <- log_posterior(current_par, data, R, p_fixed)
    }
  }
  
  if (!is.finite(current_log_post)) {
    stop("Cannot find valid starting values for MCMC")
  }
  
  # MCMC loop
  for (i in 1:n_total) {
    # Propose new parameters
    proposal <- current_par + rnorm(n_par, 0, proposal_sd)
    
    # Calculate acceptance probability
    if (all(proposal > 0)) {  # Ensure positive parameters
      proposal_log_post <- log_posterior(proposal, data, R, p_fixed)
      
      if (is.finite(proposal_log_post)) {
        log_alpha <- proposal_log_post - current_log_post
        alpha <- min(1, exp(log_alpha))
        
        # Accept or reject
        if (runif(1) < alpha) {
          current_par <- proposal
          current_log_post <- proposal_log_post
          accepted[i] <- 1
        }
      }
    }
    
    # Store samples
    samples[i, ] <- current_par
    log_post_vals[i] <- current_log_post
    
    # Adaptive proposal scaling (during burn-in)
    if (i <= n_burn && i %% 100 == 0) {
      accept_rate <- mean(accepted[(i-99):i])
      if (accept_rate < 0.2) {
        proposal_sd <- proposal_sd * 0.9
      } else if (accept_rate > 0.5) {
        proposal_sd <- proposal_sd * 1.1
      }
    }
  }
  
  # Remove burn-in
  samples_final <- samples[(n_burn + 1):n_total, ]
  log_post_final <- log_post_vals[(n_burn + 1):n_total]
  accept_rate_final <- mean(accepted[(n_burn + 1):n_total])
  
  # Convert to mcmc object for diagnostics
  mcmc_obj <- coda::mcmc(samples_final)
  
  return(list(
    samples = samples_final,
    log_posterior = log_post_final,
    accept_rate = accept_rate_final,
    mcmc_object = mcmc_obj,
    effective_size = coda::effectiveSize(mcmc_obj),
    rhat = NA  # Would need multiple chains for Rhat
  ))
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
### 4. Updated Simulation Function
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

run_one_simulation_mcmc <- function(sim_id, n_total, r, R_planned, T_ideal, true_a, true_b, true_p) {
  
  set.seed(100 + sim_id)
  
  # Generate adaptive progressive censored data (same as before)
  y_full <- sort(VGAM::rdagum(n = n_total, scale = true_b, shape1.a = true_a, shape2.p = true_p))
  
  y_obs <- numeric(r)
  R_final <- R_planned
  
  current_n <- n_total
  full_data_idx <- 1
  adapted <- FALSE
  
  for (i in 1:r) {
    y_obs[i] <- y_full[full_data_idx]
    
    if (!adapted && y_obs[i] > T_ideal) {
      adapted <- TRUE
      removed_so_far <- if (i > 1) sum(R_final[1:(i-1)]) else 0
      if (i < r) {
        R_final[(i):r] <- 0
      }
      R_final[r] <- n_total - r - removed_so_far
    }
    
    n_removed_this_step <- 1 + R_final[i]
    full_data_idx <- full_data_idx + n_removed_this_step
    current_n <- current_n - n_removed_this_step
  }
  
  y <- ifelse(y_obs <= 0, 1e-6, y_obs)
  
  results <- data.frame(mle_a=NA, mle_b=NA, bayes_a=NA, bayes_b=NA,
                        mle_cov_a=NA, mle_cov_b=NA, bayes_cov_a=NA, bayes_cov_b=NA,
                        mle_width_a=NA, mle_width_b=NA, bayes_width_a=NA, bayes_width_b=NA,
                        mle_time=NA, bayes_time=NA, adapted=adapted,
                        mcmc_accept_rate=NA, mcmc_eff_size_a=NA, mcmc_eff_size_b=NA)

  # --- MLE Estimation (same as before) ---
  mle_start_time <- Sys.time()
  start_par <- c(1.0, 1.0)
  
  mle_fit <- try(optimx(par = start_par, 
                        fn = negloglik_dagum_progressive_censored, 
                        data = y, R = R_final, p_fixed = true_p,
                        method = "nlminb", lower = c(1e-5, 1e-5), 
                        hessian = TRUE), silent = TRUE)
  
  results$mle_time <- as.numeric(difftime(Sys.time(), mle_start_time, units="secs"))
  
  if (!inherits(mle_fit, "try-error") && mle_fit$convcode == 0) {
    results$mle_a <- mle_fit$p1
    results$mle_b <- mle_fit$p2
    
    hessian_matrix <- attr(mle_fit, "details")[["nlminb", "nhatend"]]
    if (!is.null(hessian_matrix) && is.matrix(hessian_matrix)) {
      fisher_info <- try(solve(hessian_matrix), silent = TRUE)
      if (!inherits(fisher_info, "try-error") && all(diag(fisher_info) > 0)) {
        std_errors <- sqrt(diag(fisher_info))
        ci_a <- results$mle_a + c(-1,1) * 1.96 * std_errors[1]
        ci_b <- results$mle_b + c(-1,1) * 1.96 * std_errors[2]
        results$mle_width_a <- ci_a[2] - ci_a[1]
        results$mle_width_b <- ci_b[2] - ci_b[1]
        results$mle_cov_a <- (true_a > ci_a[1] && true_a < ci_a[2])
        results$mle_cov_b <- (true_b > ci_b[1] && true_b < ci_b[2])
      }
    }
  }

  # --- MCMC Bayesian Estimation ---
  bayes_start_time <- Sys.time()
  
  # Use MLE as starting point if available, otherwise use default
  mcmc_start <- if (!is.na(results$mle_a)) c(results$mle_a, results$mle_b) else c(1, 1)
  
  mcmc_result <- try(mcmc_dagum(data = y, R = R_final, p_fixed = true_p,
                                n_iter = 4000, n_burn = 1000,
                                initial_par = mcmc_start,
                                proposal_sd = c(0.05, 0.05)), silent = TRUE)
  
  results$bayes_time <- as.numeric(difftime(Sys.time(), bayes_start_time, units="secs"))
  
  if (!inherits(mcmc_result, "try-error")) {
    results$mcmc_accept_rate <- mcmc_result$accept_rate
    results$mcmc_eff_size_a <- mcmc_result$effective_size[1]
    results$mcmc_eff_size_b <- mcmc_result$effective_size[2]
    
    # Only use results if MCMC worked well
    if (results$mcmc_accept_rate > 0.15 && results$mcmc_accept_rate < 0.7 &&
        results$mcmc_eff_size_a > 100 && results$mcmc_eff_size_b > 100) {
      
      samples <- mcmc_result$samples
      results$bayes_a <- mean(samples[, 1])
      results$bayes_b <- mean(samples[, 2])
      
      # 95% credible intervals
      ci_a <- quantile(samples[, 1], c(0.025, 0.975))
      ci_b <- quantile(samples[, 2], c(0.025, 0.975))
      
      results$bayes_width_a <- ci_a[2] - ci_a[1]
      results$bayes_width_b <- ci_b[2] - ci_b[1]
      results$bayes_cov_a <- (true_a > ci_a[1] && true_a < ci_a[2])
      results$bayes_cov_b <- (true_b > ci_b[1] && true_b < ci_b[2])
    }
  }
  
  return(results)
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
### 5. Test the MCMC Implementation
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

cat("=== TESTING R-BASED MCMC IMPLEMENTATION ===\n")

# Test with simple data
test_y <- c(0.8, 1.2, 1.8)
test_R <- c(0, 0, 5)
test_p <- 1.2
true_a_test <- 2.5
true_b_test <- 1.5

cat("Testing MCMC on simple data...\n")
mcmc_test <- try(mcmc_dagum(data = test_y, R = test_R, p_fixed = test_p,
                            n_iter = 1000, n_burn = 500), silent = FALSE)

if (!inherits(mcmc_test, "try-error")) {
  cat("MCMC Test Results:\n")
  cat("Acceptance rate:", round(mcmc_test$accept_rate, 3), "\n")
  cat("Effective sample sizes:", round(mcmc_test$effective_size, 0), "\n")
  cat("Posterior means: a =", round(mean(mcmc_test$samples[,1]), 3), 
      ", b =", round(mean(mcmc_test$samples[,2]), 3), "\n")
  cat("True values: a =", true_a_test, ", b =", true_b_test, "\n")
  
  # Quick credible intervals
  ci_a <- quantile(mcmc_test$samples[,1], c(0.025, 0.975))
  ci_b <- quantile(mcmc_test$samples[,2], c(0.025, 0.975))
  cat("95% CI for a:", round(ci_a, 3), "\n")
  cat("95% CI for b:", round(ci_b, 3), "\n")
  
  cat("\nMCMC implementation appears to be working!\n")
  
} else {
  cat("MCMC test failed:", mcmc_test, "\n")
  stop("Fix MCMC implementation before proceeding")
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
### 6. Run Small-Scale Simulation
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

n_sim <- 50  # Small test first
n_total <- 100
r <- 60
true_a <- 2.5
true_b <- 1.5
true_p <- 1.2

T_ideal <- 2.0 
R_planned <- c(rep(0, r - 1), n_total - r) 

plan(multisession)

cat("\n=== RUNNING R-BASED MCMC SIMULATION ===\n")
cat("Starting", n_sim, "simulations with R-based MCMC...\n")
start_time <- Sys.time()

results_list <- future_lapply(1:n_sim, FUN = run_one_simulation_mcmc,
                              n_total=n_total, r=r, R_planned=R_planned, T_ideal=T_ideal,
                              true_a=true_a, true_b=true_b, true_p=true_p,
                              future.seed = TRUE)

end_time <- Sys.time()
cat("Simulations complete. Time:", round(end_time - start_time, 2), "seconds\n")

# Process results
final_results_df <- do.call(rbind, results_list)

# Filter for valid results
valid_bayes <- !is.na(final_results_df$bayes_a) & !is.na(final_results_df$bayes_b)
valid_mle <- !is.na(final_results_df$mle_a) & !is.na(final_results_df$mle_b)
valid_both <- valid_bayes & valid_mle

valid_results <- final_results_df[valid_both, ]

cat(sprintf("\nValid results: %d out of %d (%.1f%%)\n", 
            nrow(valid_results), nrow(final_results_df), 
            100 * nrow(valid_results) / nrow(final_results_df)))

if (nrow(valid_results) >= 20) {
  
  summary_a <- data.frame(
    Metric = c("Bias", "MSE", "Coverage", "Width"),
    MLE    = c(mean(valid_results$mle_a - true_a, na.rm=TRUE),
               mean((valid_results$mle_a - true_a)^2, na.rm=TRUE),
               mean(valid_results$mle_cov_a, na.rm=TRUE),
               mean(valid_results$mle_width_a, na.rm=TRUE)),
    Bayes  = c(mean(valid_results$bayes_a - true_a, na.rm=TRUE),
               mean((valid_results$bayes_a - true_a)^2, na.rm=TRUE),
               mean(valid_results$bayes_cov_a, na.rm=TRUE),
               mean(valid_results$bayes_width_a, na.rm=TRUE))
  )

  summary_b <- data.frame(
    Metric = c("Bias", "MSE", "Coverage", "Width"),
    MLE    = c(mean(valid_results$mle_b - true_b, na.rm=TRUE),
               mean((valid_results$mle_b - true_b)^2, na.rm=TRUE),
               mean(valid_results$mle_cov_b, na.rm=TRUE),
               mean(valid_results$mle_width_b, na.rm=TRUE)),
    Bayes  = c(mean(valid_results$bayes_b - true_b, na.rm=TRUE),
               mean((valid_results$bayes_b - true_b)^2, na.rm=TRUE),
               mean(valid_results$bayes_cov_b, na.rm=TRUE),
               mean(valid_results$bayes_width_b, na.rm=TRUE))
  )

  cat("\n=== R-BASED MCMC RESULTS ===\n")
  cat("--- Parameter 'a' ---\n")
  print(summary_a, row.names=FALSE, digits=4)
  cat("\n--- Parameter 'b' ---\n")
  print(summary_b, row.names=FALSE, digits=4)
  
  cat("\n--- MCMC Diagnostics ---\n")
  cat("Average acceptance rate:", round(mean(valid_results$mcmc_accept_rate, na.rm=TRUE), 3), "\n")
  cat("Average effective sample size - a:", round(mean(valid_results$mcmc_eff_size_a, na.rm=TRUE), 0), "\n")
  cat("Average effective sample size - b:", round(mean(valid_results$mcmc_eff_size_b, na.rm=TRUE), 0), "\n")
  
} else {
  cat("Not enough valid results for analysis\n")
}

cat("\n=== R-BASED MCMC SIMULATION COMPLETE ===\n")
```




### chatgpt code
```{r}
### Improved R-based MCMC Simulation for Dagum Distribution
library(future)
library(future.apply)
library(VGAM)
library(optimx)
library(coda)  # For MCMC diagnostics

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
### 1. Likelihood & Prior
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
negloglik_dagum_progressive_censored <- function(par, data, R, p_fixed) {
  a <- par[1]; b <- par[2]
  if (a <= 0 || b <= 0 || !is.finite(a) || !is.finite(b)) return(1e20)
  
  loglik_failures <- sum(log(ddagum(data, a, b, p_fixed)))
  survival_probs <- 1 - VGAM::pdagum(q = data, scale = b, shape1.a = a, shape2.p = p_fixed)
  loglik_censored <- sum(R * log(survival_probs))
  
  -1 * (loglik_failures + loglik_censored)
}
loglik_dagum_progressive <- function(par, data, R, p_fixed) {
  return(-negloglik_dagum_progressive_censored(par, data, R, p_fixed))
}

# Prior
log_prior <- function(par) {
  a <- par[1]; b <- par[2]
  if (a <= 0 || b <= 0) return(-Inf)
  log_a <- log(a); log_b <- log(b)
  prior_log_a <- dnorm(log_a, mean = 0, sd = 1.5, log = TRUE)
  prior_log_b <- dnorm(log_b, mean = 0, sd = 1.5, log = TRUE)
  jacobian <- log_a + log_b
  return(prior_log_a + prior_log_b + jacobian)
}

# Posterior
log_posterior <- function(par, data, R, p_fixed) {
  lp <- log_prior(par)
  if (!is.finite(lp)) return(-Inf)
  ll <- loglik_dagum_progressive(par, data, R, p_fixed)
  if (!is.finite(ll)) return(-Inf)
  return(lp + ll)
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
### 2. Multi-chain MCMC Sampler
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
mcmc_dagum <- function(data, R, p_fixed, n_iter = 20000, n_burn = 5000, 
                       initial_par = c(1, 1), proposal_sd = c(0.2, 0.2), n_chains = 3) {
  
  chain_results <- vector("list", n_chains)
  
  for (ch in 1:n_chains) {
    n_total <- n_iter + n_burn
    n_par <- length(initial_par)
    
    samples <- matrix(NA, n_total, n_par)
    log_post_vals <- numeric(n_total)
    accepted <- numeric(n_total)
    
    current_par <- initial_par + rnorm(n_par, 0, 0.1)
    current_log_post <- log_posterior(current_par, data, R, p_fixed)
    if (!is.finite(current_log_post)) {
      mle_fit <- try(optimx(par = initial_par, 
                            fn = negloglik_dagum_progressive_censored,
                            data = data, R = R, p_fixed = p_fixed,
                            method = "nlminb", lower = c(1e-5, 1e-5)), silent = TRUE)
      if (!inherits(mle_fit, "try-error") && mle_fit$convcode == 0) {
        current_par <- c(mle_fit$p1, mle_fit$p2)
        current_log_post <- log_posterior(current_par, data, R, p_fixed)
      }
    }
    if (!is.finite(current_log_post)) stop("Cannot initialize chain")
    
    for (i in 1:n_total) {
      proposal <- current_par + rnorm(n_par, 0, proposal_sd)
      if (all(proposal > 0)) {
        proposal_log_post <- log_posterior(proposal, data, R, p_fixed)
        if (is.finite(proposal_log_post)) {
          log_alpha <- proposal_log_post - current_log_post
          if (log(runif(1)) < log_alpha) {
            current_par <- proposal
            current_log_post <- proposal_log_post
            accepted[i] <- 1
          }
        }
      }
      samples[i, ] <- current_par
      log_post_vals[i] <- current_log_post
      
      # Adaptive tuning during burn-in
      if (i <= n_burn && i %% 200 == 0) {
        acc <- mean(accepted[(i-199):i])
        if (acc < 0.2) proposal_sd <- proposal_sd * 0.9
        if (acc > 0.4) proposal_sd <- proposal_sd * 1.1
      }
    }
    
    samples_final <- samples[(n_burn + 1):n_total, ]
    log_post_final <- log_post_vals[(n_burn + 1):n_total]
    accept_rate <- mean(accepted[(n_burn + 1):n_total])
    
    chain_results[[ch]] <- list(samples = samples_final,
                                log_post = log_post_final,
                                accept_rate = accept_rate)
  }
  
  # Combine chains
  mcmc_list <- mcmc.list(lapply(chain_results, function(res) mcmc(res$samples)))
  ess <- effectiveSize(mcmc_list)
  rhat <- gelman.diag(mcmc_list, autoburnin = FALSE)$psrf[,1]
  
  return(list(
    chains = chain_results,
    mcmc_list = mcmc_list,
    ess = ess,
    rhat = rhat
  ))
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
### 3. Simulation Function
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
run_one_simulation_mcmc <- function(sim_id, n_total, r, R_planned, T_ideal, true_a, true_b, true_p) {
  set.seed(100 + sim_id)
  
  # Generate adaptive progressive censored data
  y_full <- sort(VGAM::rdagum(n = n_total, scale = true_b, shape1.a = true_a, shape2.p = true_p))
  y_obs <- numeric(r); R_final <- R_planned
  current_n <- n_total; full_data_idx <- 1; adapted <- FALSE
  for (i in 1:r) {
    y_obs[i] <- y_full[full_data_idx]
    if (!adapted && y_obs[i] > T_ideal) {
      adapted <- TRUE
      removed_so_far <- if (i > 1) sum(R_final[1:(i-1)]) else 0
      if (i < r) R_final[(i):r] <- 0
      R_final[r] <- n_total - r - removed_so_far
    }
    n_removed_this_step <- 1 + R_final[i]
    full_data_idx <- full_data_idx + n_removed_this_step
    current_n <- current_n - n_removed_this_step
  }
  y <- ifelse(y_obs <= 0, 1e-6, y_obs)
  
  results <- data.frame(mle_a=NA, mle_b=NA, bayes_a=NA, bayes_b=NA,
                        mle_cov_a=NA, mle_cov_b=NA, bayes_cov_a=NA, bayes_cov_b=NA,
                        mle_width_a=NA, mle_width_b=NA, bayes_width_a=NA, bayes_width_b=NA,
                        mle_time=NA, bayes_time=NA, adapted=adapted,
                        mcmc_accept_rate=NA, mcmc_eff_size_a=NA, mcmc_eff_size_b=NA, mcmc_rhat_a=NA, mcmc_rhat_b=NA)
  
  # --- MLE ---
  mle_start_time <- Sys.time()
  start_par <- c(1.0, 1.0)
  mle_fit <- try(optimx(par = start_par, 
                        fn = negloglik_dagum_progressive_censored, 
                        data = y, R = R_final, p_fixed = true_p,
                        method = "nlminb", lower = c(1e-5, 1e-5), hessian = TRUE), silent = TRUE)
  results$mle_time <- as.numeric(difftime(Sys.time(), mle_start_time, units="secs"))
  if (!inherits(mle_fit, "try-error") && mle_fit$convcode == 0) {
    results$mle_a <- mle_fit$p1; results$mle_b <- mle_fit$p2
    hessian_matrix <- attr(mle_fit, "details")[["nlminb", "nhatend"]]
    if (!is.null(hessian_matrix) && is.matrix(hessian_matrix)) {
      fisher_info <- try(solve(hessian_matrix), silent = TRUE)
      if (!inherits(fisher_info, "try-error") && all(diag(fisher_info) > 0)) {
        std_errors <- sqrt(diag(fisher_info))
        ci_a <- results$mle_a + c(-1,1) * 1.96 * std_errors[1]
        ci_b <- results$mle_b + c(-1,1) * 1.96 * std_errors[2]
        results$mle_width_a <- ci_a[2] - ci_a[1]
        results$mle_width_b <- ci_b[2] - ci_b[1]
        results$mle_cov_a <- (true_a > ci_a[1] && true_a < ci_a[2])
        results$mle_cov_b <- (true_b > ci_b[1] && true_b < ci_b[2])
      }
    }
  }
  
  # --- Bayesian MCMC ---
  bayes_start_time <- Sys.time()
  mcmc_start <- if (!is.na(results$mle_a)) c(results$mle_a, results$mle_b) else c(1,1)
  mcmc_result <- try(mcmc_dagum(data = y, R = R_final, p_fixed = true_p,
                                n_iter = 20000, n_burn = 5000,
                                initial_par = mcmc_start,
                                proposal_sd = c(0.2,0.2),
                                n_chains = 3), silent = TRUE)
  results$bayes_time <- as.numeric(difftime(Sys.time(), bayes_start_time, units="secs"))
  if (!inherits(mcmc_result, "try-error")) {
    ess <- mcmc_result$ess; rhat <- mcmc_result$rhat
    results$mcmc_eff_size_a <- ess[1]; results$mcmc_eff_size_b <- ess[2]
    results$mcmc_rhat_a <- rhat[1]; results$mcmc_rhat_b <- rhat[2]
    accept_rates <- sapply(mcmc_result$chains, function(ch) ch$accept_rate)
    results$mcmc_accept_rate <- mean(accept_rates)
    
    if (results$mcmc_eff_size_a > 50 && results$mcmc_eff_size_b > 50 &&
        results$mcmc_rhat_a < 1.1 && results$mcmc_rhat_b < 1.1 &&
        results$mcmc_accept_rate > 0.1 && results$mcmc_accept_rate < 0.6) {
      samples <- do.call(rbind, lapply(mcmc_result$chains, function(ch) ch$samples))
      results$bayes_a <- mean(samples[,1])
      results$bayes_b <- mean(samples[,2])
      ci_a <- quantile(samples[,1], c(0.025,0.975))
      ci_b <- quantile(samples[,2], c(0.025,0.975))
      results$bayes_width_a <- ci_a[2] - ci_a[1]
      results$bayes_width_b <- ci_b[2] - ci_b[1]
      results$bayes_cov_a <- (true_a > ci_a[1] && true_a < ci_a[2])
      results$bayes_cov_b <- (true_b > ci_b[1] && true_b < ci_b[2])
    }
  }
  return(results)
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
### 4. Run Simulation
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
n_sim <- 20   # test size, increase later
n_total <- 100
r <- 60
true_a <- 2.5; true_b <- 1.5; true_p <- 1.2
T_ideal <- 2.0
R_planned <- c(rep(0, r-1), n_total - r)

plan(multisession)
cat("Running", n_sim, "simulations...\n")
results_list <- future_lapply(1:n_sim, FUN = run_one_simulation_mcmc,
                              n_total=n_total, r=r, R_planned=R_planned, T_ideal=T_ideal,
                              true_a=true_a, true_b=true_b, true_p=true_p,
                              future.seed=TRUE)
final_results_df <- do.call(rbind, results_list)

valid_bayes <- !is.na(final_results_df$bayes_a)
valid_mle <- !is.na(final_results_df$mle_a)
valid_results <- final_results_df[valid_bayes & valid_mle,]

cat("Valid results:", nrow(valid_results), "out of", n_sim, "\n")
if (nrow(valid_results) > 5) {
  summary_a <- data.frame(
    Metric=c("Bias","MSE","Coverage","Width"),
    MLE=c(mean(valid_results$mle_a - true_a,na.rm=TRUE),
          mean((valid_results$mle_a - true_a)^2,na.rm=TRUE),
          mean(valid_results$mle_cov_a,na.rm=TRUE),
          mean(valid_results$mle_width_a,na.rm=TRUE)),
    Bayes=c(mean(valid_results$bayes_a - true_a,na.rm=TRUE),
            mean((valid_results$bayes_a - true_a)^2,na.rm=TRUE),
            mean(valid_results$bayes_cov_a,na.rm=TRUE),
            mean(valid_results$bayes_width_a,na.rm=TRUE))
  )
  summary_b <- data.frame(
    Metric=c("Bias","MSE","Coverage","Width"),
    MLE=c(mean(valid_results$mle_b - true_b,na.rm=TRUE),
          mean((valid_results$mle_b - true_b)^2,na.rm=TRUE),
          mean(valid_results$mle_cov_b,na.rm=TRUE),
          mean(valid_results$mle_width_b,na.rm=TRUE)),
    Bayes=c(mean(valid_results$bayes_b - true_b,na.rm=TRUE),
            mean((valid_results$bayes_b - true_b)^2,na.rm=TRUE),
            mean(valid_results$bayes_cov_b,na.rm=TRUE),
            mean(valid_results$bayes_width_b,na.rm=TRUE))
  )
  print(summary_a,row.names=FALSE,digits=4)
  print(summary_b,row.names=FALSE,digits=4)
}

```



### stan corrected
```{r}
### Simply Fix Your Original Code - Much Easier!
library(future)
library(future.apply)
library(rstan)
library(VGAM)
library(optimx)

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
### 1. Write Corrected Stan Model
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

corrected_stan_code <- '
// CORRECTED Stan model using your working likelihood
functions {
  // Use the exact same Dagum PDF that works in R
  real dagum_lpdf(real y, real a, real b, real p) {
    if (y <= 0) {
      return negative_infinity();
    }
    
    // This matches ddagum(y, a, b, p) exactly
    real pdf_val = (a * p / pow(y, p+1)) * pow(b, p) / pow(1 + pow(y/b, -p), a+1);
    return log(pdf_val);
  }
  
  // Use the exact same survival function that works in R  
  real dagum_lccdf(real y, real a, real b, real p) {
    if (y <= 0) {
      return 0;
    }
    
    // This matches 1 - VGAM::pdagum(...) exactly
    real survival_val = pow(1 + pow(y/b, -p), -a);
    return log(survival_val);
  }
}

data {
  int<lower=0> N_obs;      
  vector<lower=0>[N_obs] y_obs; 
  int<lower=0> R[N_obs];   
  real<lower=0> p;         
}

parameters {
  real<lower=0> a;  // Use constrained parameters directly
  real<lower=0> b;
}

model {
  // Proper uninformative priors
  a ~ gamma(1, 1);  // More stable than log-normal
  b ~ gamma(1, 1);
  
  // Likelihood - matches your R function exactly
  for (i in 1:N_obs) {
    target += dagum_lpdf(y_obs[i] | a, b, p);
  }
  
  for (i in 1:N_obs) {
    if (R[i] > 0) {
      target += R[i] * dagum_lccdf(y_obs[i] | a, b, p);
    }
  }
}
'

writeLines(corrected_stan_code, "dagum_corrected.stan")

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
### 2. Use Your Original Simulation Code with One Fix
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# CORRECTED likelihood function (this works!)
negloglik_dagum_progressive_censored <- function(par, data, R, p_fixed) {
  a <- par[1]; b <- par[2]
  if (a <= 0 || b <= 0 || !is.finite(a) || !is.finite(b)) return(1e20)
  
  # KEY FIX: Use ddagum without VGAM:: prefix
  loglik_failures <- sum(log(ddagum(data, a, b, p_fixed)))
  survival_probs <- 1 - VGAM::pdagum(q = data, scale = b, shape1.a = a, shape2.p = p_fixed)
  loglik_censored <- sum(R * log(survival_probs))
  
  -1 * (loglik_failures + loglik_censored)
}

# Test the likelihood function
cat("Testing corrected likelihood...\n")
test_result <- negloglik_dagum_progressive_censored(c(2.5, 1.5), c(0.5, 1.0, 1.5, 2.0, 3.0), c(0,0,2,0,5), 1.2)
cat("Result:", test_result, "(should be 16.86)\n")

if (abs(test_result - 16.86103) > 0.001) {
  stop("Likelihood function still not working correctly!")
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
### 3. Compile and Test Stan Model
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

cat("Compiling corrected Stan model...\n")
stan_model_compiled <- rstan::stan_model("dagum_corrected.stan")
cat("Compilation successful!\n")

# Test Stan model
test_data <- list(N_obs = 3, y_obs = c(0.8, 1.2, 1.8), R = c(0, 0, 5), p = 1.2)

cat("Testing Stan model...\n")
test_fit <- rstan::sampling(stan_model_compiled, data = test_data, 
                           chains = 2, iter = 1000, warmup = 500, 
                           verbose = FALSE, refresh = 0)

if (!inherits(test_fit, "try-error")) {
  test_summary <- summary(test_fit)$summary
  cat("Stan test successful!\n")
  cat("Parameter estimates: a =", round(test_summary["a", "mean"], 3), 
      ", b =", round(test_summary["b", "mean"], 3), "\n")
} else {
  stop("Stan model test failed!")
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
### 4. Your Original Simulation Function with Fixes
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

run_one_simulation <- function(sim_id, n_total, r, R_planned, T_ideal, true_a, true_b, true_p, compiled_model) {
  
  set.seed(100 + sim_id)
  
  # Generate data (same as before)
  y_full <- sort(VGAM::rdagum(n = n_total, scale = true_b, shape1.a = true_a, shape2.p = true_p))
  
  y_obs <- numeric(r)
  R_final <- R_planned
  current_n <- n_total
  full_data_idx <- 1
  adapted <- FALSE
  
  for (i in 1:r) {
    y_obs[i] <- y_full[full_data_idx]
    
    if (!adapted && y_obs[i] > T_ideal) {
      adapted <- TRUE
      removed_so_far <- if (i > 1) sum(R_final[1:(i-1)]) else 0
      if (i < r) {
        R_final[(i):r] <- 0
      }
      R_final[r] <- n_total - r - removed_so_far
    }
    
    n_removed_this_step <- 1 + R_final[i]
    full_data_idx <- full_data_idx + n_removed_this_step
    current_n <- current_n - n_removed_this_step
  }
  
  y <- ifelse(y_obs <= 0, 1e-6, y_obs)
  N <- length(y)
  
  results <- data.frame(mle_a=NA, mle_b=NA, bayes_a=NA, bayes_b=NA,
                        mle_cov_a=NA, mle_cov_b=NA, bayes_cov_a=NA, bayes_cov_b=NA,
                        mle_width_a=NA, mle_width_b=NA, bayes_width_a=NA, bayes_width_b=NA,
                        mle_time=NA, bayes_time=NA, adapted=adapted, divergences=NA,
                        valid_bayes=FALSE)

  # Bayesian estimation with corrected Stan model
  bayes_start_time <- Sys.time()
  stan_data <- list(N_obs = N, y_obs = y, R = R_final, p = true_p)
  
  stan_fit <- try(rstan::sampling(object = compiled_model,
                                  data = stan_data,
                                  chains = 4, iter = 2000, warmup = 1000,
                                  verbose = FALSE, refresh = 0,
                                  control = list(adapt_delta = 0.95)), silent = TRUE)
  
  results$bayes_time <- as.numeric(difftime(Sys.time(), bayes_start_time, units="secs"))
  
  if (!inherits(stan_fit, "try-error")) {
    sampler_params <- get_sampler_params(stan_fit, inc_warmup = FALSE)
    divergences <- sum(sapply(sampler_params, function(x) sum(x[, "divergent__"])))
    results$divergences <- divergences
    
    summary_stats <- rstan::summary(stan_fit)$summary
    rhats <- summary_stats[, "Rhat"]
    
    if (all(rhats < 1.1, na.rm = TRUE) && divergences <= 5) {
        results$valid_bayes <- TRUE
        results$bayes_a <- summary_stats["a", "mean"]
        results$bayes_b <- summary_stats["b", "mean"]
        
        results$bayes_width_a <- summary_stats["a", "97.5%"] - summary_stats["a", "2.5%"]
        results$bayes_width_b <- summary_stats["b", "97.5%"] - summary_stats["b", "2.5%"]
        results$bayes_cov_a <- (true_a > summary_stats["a", "2.5%"] && true_a < summary_stats["a", "97.5%"])
        # FIXED BUG: Correct coverage calculation for b
        results$bayes_cov_b <- (true_b > summary_stats["b", "2.5%"] && true_b < summary_stats["b", "97.5%"])
    }
  }

  # MLE estimation (same as before, with corrected starting values)
  mle_start_time <- Sys.time()
  start_par <- c(1.0, 1.0)  # Fair starting values
  
  mle_fit <- try(optimx(par=start_par, fn=negloglik_dagum_progressive_censored, 
                        data=y, R=R_final, p_fixed=true_p,
                        method="nlminb", lower=c(1e-5, 1e-5), hessian=TRUE), silent=TRUE)
  results$mle_time <- as.numeric(difftime(Sys.time(), mle_start_time, units="secs"))
  
  if (!inherits(mle_fit, "try-error") && mle_fit$convcode == 0) {
    results$mle_a <- mle_fit$p1
    results$mle_b <- mle_fit$p2
    hessian_matrix <- attr(mle_fit, "details")[["nlminb", "nhatend"]]
      if (!is.null(hessian_matrix) && is.matrix(hessian_matrix)) {
        fisher_info <- try(solve(hessian_matrix), silent=TRUE)
        if (!inherits(fisher_info, "try-error") && all(diag(fisher_info) > 0)) {
          std_errors <- sqrt(diag(fisher_info))
          ci_a <- results$mle_a + c(-1,1) * 1.96 * std_errors[1]
          ci_b <- results$mle_b + c(-1,1) * 1.96 * std_errors[2]
          results$mle_width_a <- ci_a[2] - ci_a[1]
          results$mle_width_b <- ci_b[2] - ci_b[1]
          results$mle_cov_a <- (true_a > ci_a[1] && true_a < ci_a[2])
          results$mle_cov_b <- (true_b > ci_b[1] && true_b < ci_b[2])
        }
      }
  }
  return(results)
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
### 5. Run the Simulation
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

n_sim <- 100  # Test with 100 first
n_total <- 100
r <- 60
true_a <- 2.5
true_b <- 1.5
true_p <- 1.2
T_ideal <- 2.0 
R_planned <- c(rep(0, r - 1), n_total - r) 

plan(multisession)

cat("Starting corrected simulation with", n_sim, "runs...\n")
start_time <- Sys.time()

results_list <- future_lapply(1:n_sim, FUN = run_one_simulation,
                              n_total=n_total, r=r, R_planned=R_planned, T_ideal=T_ideal,
                              true_a=true_a, true_b=true_b, true_p=true_p,
                              compiled_model = stan_model_compiled,
                              future.seed = TRUE)

end_time <- Sys.time()
cat("Simulation complete. Time:", round(end_time - start_time, 2), "seconds\n")

# Process results
final_results_df <- do.call(rbind, results_list)
valid_results <- final_results_df[final_results_df$valid_bayes == TRUE, ]

cat(sprintf("Valid Bayesian results: %d out of %d (%.1f%%)\n", 
            nrow(valid_results), nrow(final_results_df), 
            100 * nrow(valid_results) / nrow(final_results_df)))

if (nrow(valid_results) >= 20) {
  
  summary_a <- data.frame(
    Metric = c("Bias", "MSE", "Coverage", "Width"),
    MLE    = c(mean(valid_results$mle_a - true_a, na.rm=TRUE),
               mean((valid_results$mle_a - true_a)^2, na.rm=TRUE),
               mean(valid_results$mle_cov_a, na.rm=TRUE),
               mean(valid_results$mle_width_a, na.rm=TRUE)),
    Bayes  = c(mean(valid_results$bayes_a - true_a, na.rm=TRUE),
               mean((valid_results$bayes_a - true_a)^2, na.rm=TRUE),
               mean(valid_results$bayes_cov_a, na.rm=TRUE),
               mean(valid_results$bayes_width_a, na.rm=TRUE))
  )

  summary_b <- data.frame(
    Metric = c("Bias", "MSE", "Coverage", "Width"),
    MLE    = c(mean(valid_results$mle_b - true_b, na.rm=TRUE),
               mean((valid_results$mle_b - true_b)^2, na.rm=TRUE),
               mean(valid_results$mle_cov_b, na.rm=TRUE),
               mean(valid_results$mle_width_b, na.rm=TRUE)),
    Bayes  = c(mean(valid_results$bayes_b - true_b, na.rm=TRUE),
               mean((valid_results$bayes_b - true_b)^2, na.rm=TRUE),
               mean(valid_results$bayes_cov_b, na.rm=TRUE),
               mean(valid_results$bayes_width_b, na.rm=TRUE))
  )

  cat("\n=== CORRECTED RESULTS ===\n")
  cat("--- Parameter 'a' ---\n")
  print(summary_a, row.names=FALSE, digits=4)
  cat("\n--- Parameter 'b' ---\n")
  print(summary_b, row.names=FALSE, digits=4)
  
  cat("\n--- SUCCESS INDICATORS ---\n")
  if (summary_a$Bayes[2] < summary_a$MLE[2]) cat(" Bayesian MSE better for parameter 'a'\n")
  if (summary_b$Bayes[2] < summary_b$MLE[2]) cat(" Bayesian MSE better for parameter 'b'\n")
  if (summary_a$Bayes[3] > 0.9) cat(" Bayesian coverage good for parameter 'a'\n")
  if (summary_b$Bayes[3] > 0.9) cat(" Bayesian coverage good for parameter 'b'\n")
  
} else {
  cat("Not enough valid results. Check model specification.\n")
}

cat("\n=== CORRECTED SIMULATION COMPLETE ===\n")
```

### claude diagnostic
```{r}
### Fix Fundamental Parameter Mapping Issue
library(VGAM)
library(optimx)

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
### 1. CRITICAL DIAGNOSIS: Parameter Mapping Investigation
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

diagnose_parameter_mapping <- function() {
  cat("=== DIAGNOSING PARAMETER MAPPING ISSUE ===\n")
  
  # Test parameters
  test_a <- 2.5; test_b <- 1.5; test_p <- 1.2
  
  cat("Testing data generation and fitting consistency...\n")
  
  # Generate test data
  set.seed(123)
  n_test <- 1000
  
  cat("\n1. Testing VGAM data generation:\n")
  cat("Using: VGAM::rdagum(n=", n_test, ", scale=", test_b, ", shape1.a=", test_a, ", shape2.p=", test_p, ")\n")
  
  # Generate data using VGAM
  test_data <- VGAM::rdagum(n = n_test, scale = test_b, shape1.a = test_a, shape2.p = test_p)
  
  cat("Data summary: min=", round(min(test_data), 3), 
      ", mean=", round(mean(test_data), 3), 
      ", max=", round(max(test_data), 3), "\n")
  
  cat("\n2. Testing different ddagum functions:\n")
  
  # Test which ddagum function was used for generation
  # Method 1: ddagum from global environment
  cat("Method A - ddagum(data, a, b, p):\n")
  pdf_A <- mean(ddagum(test_data[1:5], test_a, test_b, test_p))
  cat("Average PDF:", round(pdf_A, 6), "\n")
  
  # Method 2: VGAM::ddagum (if it exists and works)
  cat("Method B - Trying different VGAM parameter orders:\n")
  
  # Test VGAM::ddagum with different parameter interpretations
  try({
    # Maybe VGAM uses different parameter names/order
    pdf_B1 <- mean(VGAM::ddagum(test_data[1:5], scale=test_b, shape1.a=test_a, shape2.p=test_p))
    cat("VGAM method 1 average PDF:", round(pdf_B1, 6), "\n")
  }, silent = FALSE)
  
  cat("\n3. Testing parameter recovery with CORRECT functions:\n")
  
  # Create likelihood function that matches data generation
  # We need to figure out what the correct mapping is
  
  # Test different parameter interpretations
  test_mappings <- list(
    list(name = "ddagum(x, a, b, p)", 
         fun = function(data, pars) -sum(log(ddagum(data, pars[1], pars[2], test_p)))),
    list(name = "ddagum(x, b, a, p)", 
         fun = function(data, pars) -sum(log(ddagum(data, pars[2], pars[1], test_p)))),
    list(name = "ddagum(x, a, p, b)", 
         fun = function(data, pars) -sum(log(ddagum(data, pars[1], test_p, pars[2]))))
  )
  
  cat("\nTesting different parameter mappings:\n")
  for (i in 1:length(test_mappings)) {
    mapping <- test_mappings[[i]]
    
    tryCatch({
      # Try to recover original parameters
      fit <- optimx(par = c(1, 1), fn = mapping$fun, data = test_data,
                   method = "nlminb", lower = c(0.1, 0.1), upper = c(10, 10))
      
      if (fit$convcode == 0) {
        cat(mapping$name, ": a=", round(fit$p1, 3), ", b=", round(fit$p2, 3))
        # Check if this recovers the original parameters
        recovery_a <- abs(fit$p1 - test_a) < 0.2
        recovery_b <- abs(fit$p2 - test_b) < 0.2
        cat(" | Recovery: a=", recovery_a, ", b=", recovery_b)
        if (recovery_a && recovery_b) cat(" *** CORRECT MAPPING! ***")
        cat("\n")
      }
    }, error = function(e) {
      cat(mapping$name, ": ERROR -", e$message, "\n")
    })
  }
  
  cat("\n4. Testing VGAM consistency:\n")
  # Check if VGAM generation and fitting use the same parameterization
  
  # Generate small dataset and try to fit with VGAM functions
  small_data <- VGAM::rdagum(n = 100, scale = test_b, shape1.a = test_a, shape2.p = test_p)
  
  cat("Generated data with VGAM: mean=", round(mean(small_data), 3), 
      ", median=", round(median(small_data), 3), "\n")
  
  # Try to fit using VGAM dagum fit if available
  try({
    if (exists("vglm")) {
      cat("Attempting VGAM model fit...\n")
      vgam_fit <- vglm(small_data ~ 1, dagum(), trace = FALSE)
      cat("VGAM fit successful\n")
      print(coef(vgam_fit))
    }
  }, silent = FALSE)
  
  return(NULL)
}

# Run the diagnosis
diagnose_parameter_mapping()

cat("\n", paste(rep("=", 60), collapse=""), "\n")
cat("NEXT STEPS BASED ON DIAGNOSIS:\n")
cat("1. Identify which parameter mapping works (look for '*** CORRECT MAPPING! ***')\n")
cat("2. Use that mapping for both data generation verification and simulation\n")
cat("3. Ensure consistency between generation and fitting functions\n")
cat(paste(rep("=", 60), collapse=""), "\n")

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
### 2. Alternative: Use Only VGAM Functions Throughout
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

cat("\n=== ALTERNATIVE APPROACH: PURE VGAM IMPLEMENTATION ===\n")

# Create likelihood function using only VGAM functions
vgam_only_negloglik <- function(par, data, R, p_fixed) {
  a <- par[1]; b <- par[2]
  if (a <= 0 || b <= 0 || !is.finite(a) || !is.finite(b)) return(1e20)
  
  tryCatch({
    # Use VGAM functions for both PDF and survival
    ll_failures <- sum(VGAM::ddagum(data, scale = b, shape1.a = a, shape2.p = p_fixed, log = TRUE))
    
    # For survival: use complementary CDF
    survival_probs <- VGAM::pdagum(data, scale = b, shape1.a = a, shape2.p = p_fixed, lower.tail = FALSE)
    ll_censored <- sum(R * log(survival_probs))
    
    total_ll <- ll_failures + ll_censored
    return(-total_ll)
    
  }, error = function(e) {
    return(1e20)
  })
}

cat("Testing VGAM-only approach:\n")

# Test data generation and recovery using only VGAM
set.seed(456)
vgam_test_data <- VGAM::rdagum(n = 500, scale = 1.5, shape1.a = 2.5, shape2.p = 1.2)

cat("VGAM test data: mean=", round(mean(vgam_test_data), 3), 
    ", range=[", round(min(vgam_test_data), 3), ",", round(max(vgam_test_data), 3), "]\n")

# Try to recover parameters using VGAM-only likelihood
vgam_recovery <- try(optimx(par = c(1, 1), 
                           fn = vgam_only_negloglik,
                           data = vgam_test_data, R = rep(0, length(vgam_test_data)), p_fixed = 1.2,
                           method = "nlminb", lower = c(0.1, 0.1), upper = c(8, 8)), 
                    silent = FALSE)

if (!inherits(vgam_recovery, "try-error") && vgam_recovery$convcode == 0) {
  cat("VGAM recovery result: a=", round(vgam_recovery$p1, 3), ", b=", round(vgam_recovery$p2, 3), "\n")
  cat("True values:          a= 2.5 , b= 1.5\n")
  cat("VGAM recovery successful:", 
      abs(vgam_recovery$p1 - 2.5) < 0.3 && abs(vgam_recovery$p2 - 1.5) < 0.3, "\n")
} else {
  cat("VGAM recovery failed\n")
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
### 3. Create Corrected Simulation Based on Findings
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

cat("\n=== BASED ON DIAGNOSIS RESULTS ===\n")
cat("Choose the approach that works:\n")
cat("A. If parameter mapping diagnosis found correct mapping -> Use that\n")
cat("B. If VGAM-only approach works -> Use pure VGAM implementation\n") 
cat("C. If both fail -> Need to investigate Dagum distribution implementation\n")

# Template for corrected implementation (to be filled based on diagnosis)
create_corrected_simulation <- function(approach = "WAIT_FOR_DIAGNOSIS") {
  
  if (approach == "WAIT_FOR_DIAGNOSIS") {
    cat("Please run the diagnosis first and identify the working approach\n")
    return(NULL)
  }
  
  # This will be implemented based on diagnosis results
  cat("Implementation will be created based on diagnosis results...\n")
}

cat("\n=== DIAGNOSIS COMPLETE ===\n")
cat("Please review the diagnosis output above and let me know:\n")
cat("1. Which parameter mapping (if any) shows '*** CORRECT MAPPING! ***'\n") 
cat("2. Whether the VGAM-only approach recovery was successful\n")
cat("3. Any error messages that appeared\n")
cat("\nBased on this information, I'll create the corrected simulation code.\n")
```

### verified dagum - ultimate final boss
```{r}
### Working Solution: Create Our Own Verified Dagum Implementation
library(future)
library(future.apply)
library(rstan)
library(optimx)

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
### 1. Create Our Own Verified Dagum Functions
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Dagum PDF: f(x; a, b, p) = (a*p/x^(p+1)) * b^p / (1 + (x/b)^(-p))^(a+1)
dagum_pdf <- function(x, a, b, p) {
  if (any(x <= 0) || a <= 0 || b <= 0 || p <= 0) return(rep(0, length(x)))
  
  term1 <- a * p
  term2 <- x^(-(p + 1))
  term3 <- b^p
  term4 <- (1 + (x/b)^(-p))^(-(a + 1))
  
  return(term1 * term2 * term3 * term4)
}

# Dagum CDF: F(x; a, b, p) = 1 - (1 + (x/b)^(-p))^(-a)
dagum_cdf <- function(x, a, b, p) {
  if (any(x <= 0) || a <= 0 || b <= 0 || p <= 0) return(rep(0, length(x)))
  
  return(1 - (1 + (x/b)^(-p))^(-a))
}

# Dagum random generation using inverse transform
dagum_random <- function(n, a, b, p) {
  if (a <= 0 || b <= 0 || p <= 0) stop("Parameters must be positive")
  
  u <- runif(n)
  # Inverse CDF: x = b * ((1-u)^(-1/a) - 1)^(-1/p)
  x <- b * ((1 - u)^(-1/a) - 1)^(-1/p)
  
  return(x)
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
### 2. Verify Our Implementation Works
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

verify_our_implementation <- function() {
  cat("=== VERIFYING OUR DAGUM IMPLEMENTATION ===\n")
  
  # Test parameters
  a <- 2.5; b <- 1.5; p <- 1.2
  
  # Generate test data
  set.seed(123)
  test_data <- dagum_random(n = 1000, a = a, b = b, p = p)
  
  cat("Generated data summary: min=", round(min(test_data), 3), 
      ", mean=", round(mean(test_data), 3), 
      ", max=", round(max(test_data), 3), "\n")
  
  # Test parameter recovery
  our_negloglik <- function(par, data) {
    if (any(par <= 0)) return(1e20)
    pdf_vals <- dagum_pdf(data, par[1], par[2], p)
    if (any(pdf_vals <= 0)) return(1e20)
    return(-sum(log(pdf_vals)))
  }
  
  recovery_fit <- optimx(par = c(1, 1), fn = our_negloglik, data = test_data,
                        method = "nlminb", lower = c(0.1, 0.1), upper = c(10, 10))
  
  if (recovery_fit$convcode == 0) {
    recovered_a <- recovery_fit$p1
    recovered_b <- recovery_fit$p2
    
    cat("Parameter recovery test:\n")
    cat("True:      a =", a, ", b =", b, "\n")
    cat("Recovered: a =", round(recovered_a, 3), ", b =", round(recovered_b, 3), "\n")
    
    success_a <- abs(recovered_a - a) < 0.2
    success_b <- abs(recovered_b - b) < 0.2
    
    cat("Recovery successful: a =", success_a, ", b =", success_b, "\n")
    
    if (success_a && success_b) {
      cat("*** OUR IMPLEMENTATION WORKS! ***\n")
      return(TRUE)
    }
  }
  
  cat("Parameter recovery failed\n")
  return(FALSE)
}

# Test our implementation
implementation_works <- verify_our_implementation()

if (!implementation_works) {
  stop("Our Dagum implementation doesn't work properly. Check the mathematical formulation.")
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
### 3. Progressive Censoring Likelihood with Our Functions
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

negloglik_progressive_censored_verified <- function(par, data, R, p_fixed) {
  a <- par[1]; b <- par[2]
  if (a <= 0 || b <= 0 || !is.finite(a) || !is.finite(b)) return(1e20)
  
  # Log-likelihood from observed failures
  pdf_vals <- dagum_pdf(data, a, b, p_fixed)
  if (any(pdf_vals <= 0) || any(!is.finite(pdf_vals))) return(1e20)
  ll_failures <- sum(log(pdf_vals))
  
  # Log-likelihood from censored observations
  if (sum(R) > 0) {
    cdf_vals <- dagum_cdf(data, a, b, p_fixed)
    survival_vals <- 1 - cdf_vals
    if (any(survival_vals <= 0) || any(!is.finite(survival_vals))) return(1e20)
    ll_censored <- sum(R * log(survival_vals))
  } else {
    ll_censored <- 0
  }
  
  return(-(ll_failures + ll_censored))
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
### 4. Verified Stan Model
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

verified_stan_code <- '
functions {
  real dagum_lpdf(real x, real a, real b, real p) {
    if (x <= 0) return negative_infinity();
    
    real log_pdf = log(a) + log(p) - (p + 1) * log(x) + p * log(b) - (a + 1) * log1p(pow(x/b, -p));
    return log_pdf;
  }
  
  real dagum_lccdf(real x, real a, real b, real p) {
    if (x <= 0) return 0;
    
    return -a * log1p(pow(x/b, -p));
  }
}

data {
  int<lower=0> N_obs;
  vector<lower=0>[N_obs] y_obs;
  int<lower=0> R[N_obs];
  real<lower=0> p;
}

parameters {
  real<lower=0> a;
  real<lower=0> b;
}

model {
  // Weakly informative priors
  a ~ gamma(2, 1);  // mean = 2, variance = 2
  b ~ gamma(2, 1);  // mean = 2, variance = 2
  
  // Likelihood
  for (i in 1:N_obs) {
    target += dagum_lpdf(y_obs[i] | a, b, p);
  }
  
  for (i in 1:N_obs) {
    if (R[i] > 0) {
      target += R[i] * dagum_lccdf(y_obs[i] | a, b, p);
    }
  }
}
'

writeLines(verified_stan_code, "dagum_verified.stan")

# Compile Stan model
cat("Compiling verified Stan model...\n")
stan_model_compiled <- rstan::stan_model("dagum_verified.stan")
cat("Stan model compiled successfully!\n")

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
### 5. Working Simulation Function
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

run_verified_simulation <- function(sim_id, n_total, r, R_planned, T_ideal, true_a, true_b, true_p, compiled_model) {
  
  set.seed(100 + sim_id)
  
  # Generate data using OUR verified function
  y_full <- sort(dagum_random(n = n_total, a = true_a, b = true_b, p = true_p))
  
  y_obs <- numeric(r)
  R_final <- R_planned
  current_n <- n_total
  full_data_idx <- 1
  adapted <- FALSE
  
  # Adaptive progressive censoring
  for (i in 1:r) {
    y_obs[i] <- y_full[full_data_idx]
    
    if (!adapted && y_obs[i] > T_ideal) {
      adapted <- TRUE
      removed_so_far <- if (i > 1) sum(R_final[1:(i-1)]) else 0
      if (i < r) {
        R_final[i:r] <- 0
      }
      R_final[r] <- n_total - r - removed_so_far
    }
    
    n_removed_this_step <- 1 + R_final[i]
    full_data_idx <- full_data_idx + n_removed_this_step
    current_n <- current_n - n_removed_this_step
  }
  
  y <- pmax(y_obs, 1e-6)
  
  results <- data.frame(
    mle_a = NA, mle_b = NA, bayes_a = NA, bayes_b = NA,
    mle_cov_a = NA, mle_cov_b = NA, bayes_cov_a = NA, bayes_cov_b = NA,
    mle_width_a = NA, mle_width_b = NA, bayes_width_a = NA, bayes_width_b = NA,
    mle_time = NA, bayes_time = NA, adapted = adapted,
    divergences = NA, valid_bayes = FALSE
  )

  # MLE estimation using verified likelihood
  mle_start_time <- Sys.time()
  
  # Multiple starting points for robustness
  start_points <- list(c(1, 1), c(2, mean(y)), c(true_a*0.8, true_b*0.8))
  
  best_mle <- NULL
  best_nll <- Inf
  
  for (start_par in start_points) {
    mle_fit <- try(optimx(par = start_par, 
                          fn = negloglik_progressive_censored_verified,
                          data = y, R = R_final, p_fixed = true_p,
                          method = "nlminb", lower = c(0.1, 0.1), upper = c(10, 10)), silent = TRUE)
    
    if (!inherits(mle_fit, "try-error") && mle_fit$convcode == 0 && mle_fit$value < best_nll) {
      best_mle <- mle_fit
      best_nll <- mle_fit$value
    }
  }
  
  results$mle_time <- as.numeric(difftime(Sys.time(), mle_start_time, units = "secs"))
  
  if (!is.null(best_mle)) {
    results$mle_a <- best_mle$p1
    results$mle_b <- best_mle$p2
    
    # Bootstrap confidence intervals (more reliable than Hessian)
    bootstrap_cis <- try({
      n_boot <- 200
      boot_results <- matrix(NA, n_boot, 2)
      
      for (b in 1:n_boot) {
        # Bootstrap sample
        boot_indices <- sample(length(y), replace = TRUE)
        boot_y <- y[boot_indices]
        boot_R <- R_final[boot_indices]
        
        boot_fit <- try(optimx(par = c(results$mle_a, results$mle_b),
                               fn = negloglik_progressive_censored_verified,
                               data = boot_y, R = boot_R, p_fixed = true_p,
                               method = "nlminb", lower = c(0.1, 0.1), upper = c(10, 10)), silent = TRUE)
        
        if (!inherits(boot_fit, "try-error") && boot_fit$convcode == 0) {
          boot_results[b, ] <- c(boot_fit$p1, boot_fit$p2)
        }
      }
      
      # Remove failed bootstrap samples
      valid_boots <- complete.cases(boot_results)
      if (sum(valid_boots) >= 50) {
        boot_results <- boot_results[valid_boots, ]
        
        ci_a <- quantile(boot_results[, 1], c(0.025, 0.975), na.rm = TRUE)
        ci_b <- quantile(boot_results[, 2], c(0.025, 0.975), na.rm = TRUE)
        
        list(ci_a = ci_a, ci_b = ci_b)
      } else {
        NULL
      }
    }, silent = TRUE)
    
    if (!inherits(bootstrap_cis, "try-error") && !is.null(bootstrap_cis)) {
      results$mle_width_a <- bootstrap_cis$ci_a[2] - bootstrap_cis$ci_a[1]
      results$mle_width_b <- bootstrap_cis$ci_b[2] - bootstrap_cis$ci_b[1]
      results$mle_cov_a <- (true_a >= bootstrap_cis$ci_a[1] && true_a <= bootstrap_cis$ci_a[2])
      results$mle_cov_b <- (true_b >= bootstrap_cis$ci_b[1] && true_b <= bootstrap_cis$ci_b[2])
    }
  }

  # Bayesian estimation
  bayes_start_time <- Sys.time()
  stan_data <- list(N_obs = length(y), y_obs = y, R = R_final, p = true_p)
  
  stan_fit <- try(rstan::sampling(
    object = compiled_model,
    data = stan_data,
    chains = 4, iter = 2000, warmup = 1000,
    verbose = FALSE, refresh = 0,
    control = list(adapt_delta = 0.95)
  ), silent = TRUE)
  
  results$bayes_time <- as.numeric(difftime(Sys.time(), bayes_start_time, units = "secs"))
  
  if (!inherits(stan_fit, "try-error")) {
    sampler_params <- get_sampler_params(stan_fit, inc_warmup = FALSE)
    divergences <- sum(sapply(sampler_params, function(x) sum(x[, "divergent__"])))
    results$divergences <- divergences
    
    summary_stats <- rstan::summary(stan_fit)$summary
    rhats <- summary_stats[, "Rhat"]
    
    if (all(rhats < 1.1, na.rm = TRUE) && divergences <= 10) {
      results$valid_bayes <- TRUE
      results$bayes_a <- summary_stats["a", "mean"]
      results$bayes_b <- summary_stats["b", "mean"]
      
      results$bayes_width_a <- summary_stats["a", "97.5%"] - summary_stats["a", "2.5%"]
      results$bayes_width_b <- summary_stats["b", "97.5%"] - summary_stats["b", "2.5%"]
      results$bayes_cov_a <- (true_a >= summary_stats["a", "2.5%"] && true_a <= summary_stats["a", "97.5%"])
      results$bayes_cov_b <- (true_b >= summary_stats["b", "2.5%"] && true_b <= summary_stats["b", "97.5%"])
    }
  }
  
  return(results)
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
### 6. Run the Verified Simulation
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Simulation parameters
n_sim <- 1000
n_total <- 100
r <- 60
true_a <- 2.5
true_b <- 1.5
true_p <- 1.2
T_ideal <- 2.0
R_planned <- c(rep(0, r - 1), n_total - r)

plan(multisession)

cat("Starting VERIFIED simulation with consistent Dagum implementation...\n")
start_time <- Sys.time()

results_list <- future_lapply(1:n_sim, FUN = run_verified_simulation,
                              n_total = n_total, r = r, R_planned = R_planned, T_ideal = T_ideal,
                              true_a = true_a, true_b = true_b, true_p = true_p,
                              compiled_model = stan_model_compiled,
                              future.seed = TRUE)

end_time <- Sys.time()
cat("Verified simulation complete. Time:", round(end_time - start_time, 2), "seconds\n")

# Process results
final_results_df <- do.call(rbind, results_list)
valid_results <- final_results_df[final_results_df$valid_bayes == TRUE, ]

cat(sprintf("Valid Bayesian results: %d out of %d (%.1f%%)\n", 
            nrow(valid_results), nrow(final_results_df), 
            100 * nrow(valid_results) / nrow(final_results_df)))

if (nrow(valid_results) >= 20) {
  
  summary_a <- data.frame(
    Metric = c("Bias", "AbsBias", "MSE", "Coverage", "Width"),
    MLE = c(
      mean(valid_results$mle_a - true_a, na.rm = TRUE),
      mean(abs(valid_results$mle_a - true_a), na.rm = TRUE),
      mean((valid_results$mle_a - true_a)^2, na.rm = TRUE),
      mean(valid_results$mle_cov_a, na.rm = TRUE),
      mean(valid_results$mle_width_a, na.rm = TRUE)
    ),
    Bayes = c(
      mean(valid_results$bayes_a - true_a, na.rm = TRUE),
      mean(abs(valid_results$bayes_a - true_a), na.rm = TRUE),
      mean((valid_results$bayes_a - true_a)^2, na.rm = TRUE),
      mean(valid_results$bayes_cov_a, na.rm = TRUE),
      mean(valid_results$bayes_width_a, na.rm = TRUE)
    )
  )
  
  summary_b <- data.frame(
    Metric = c("Bias", "AbsBias", "MSE", "Coverage", "Width"),
    MLE = c(
      mean(valid_results$mle_b - true_b, na.rm = TRUE),
      mean(abs(valid_results$mle_b - true_b), na.rm = TRUE),
      mean((valid_results$mle_b - true_b)^2, na.rm = TRUE),
      mean(valid_results$mle_cov_b, na.rm = TRUE),
      mean(valid_results$mle_width_b, na.rm = TRUE)
    ),
    Bayes = c(
      mean(valid_results$bayes_b - true_b, na.rm = TRUE),
      mean(abs(valid_results$bayes_b - true_b), na.rm = TRUE),
      mean((valid_results$bayes_b - true_b)^2, na.rm = TRUE),
      mean(valid_results$bayes_cov_b, na.rm = TRUE),
      mean(valid_results$bayes_width_b, na.rm = TRUE)
    )
  )
  
  cat("\n=== VERIFIED SIMULATION RESULTS ===\n")
  cat("--- Parameter 'a' ---\n")
  print(summary_a, row.names = FALSE, digits = 4)
  cat("\n--- Parameter 'b' ---\n")
  print(summary_b, row.names = FALSE, digits = 4)
  
  cat("\n--- SUCCESS INDICATORS ---\n")
  if (summary_a$Bayes[3] < summary_a$MLE[3]) cat(" Bayesian MSE better for parameter 'a'\n")
  if (summary_b$Bayes[3] < summary_b$MLE[3]) cat(" Bayesian MSE better for parameter 'b'\n")
  if (summary_a$Bayes[2] < summary_a$MLE[2]) cat(" Bayesian absolute bias better for parameter 'a'\n")
  if (summary_b$Bayes[2] < summary_b$MLE[2]) cat(" Bayesian absolute bias better for parameter 'b'\n")
  if (summary_a$Bayes[4] > 0.9) cat(" Good Bayesian coverage for parameter 'a'\n")
  if (summary_b$Bayes[4] > 0.9) cat(" Good Bayesian coverage for parameter 'b'\n")
  
  cat("\n--- Diagnostics ---\n")
  cat("Average divergences:", round(mean(valid_results$divergences, na.rm = TRUE), 1), "\n")
  cat("Adaptation rate:", round(100 * mean(valid_results$adapted, na.rm = TRUE), 1), "%\n")
  
} else {
  cat("Insufficient successful results. Check implementation.\n")
}

cat("\n=== VERIFIED SIMULATION COMPLETE ===\n")
cat("This implementation uses consistent Dagum functions throughout.\n")
cat("If results are still problematic, the issue may be with the progressive censoring scheme or parameter values.\n")
```

