---
title: "final simulation with p fixed"
author: "Anjali Alex"
date: "2025-08-15"
output: html_document
---

### 1. Load libraries
```{r setup, message=FALSE, warning=FALSE}
library(rjags)
library(coda)
library(actuar)
library(VGAM)
```

### 2. Define updated MLE function
```{r}
  negloglik_dagum_p_fixed <- function(par, data, p_fixed) {
  a <- par[1]
  b <- par[2]
  if (a <= 0 || b <= 0) return(Inf)
  -sum(actuar::ddagum(x = data, shape1.a = a, scale = b, shape2.p = p_fixed, log = TRUE))
}
```

### 3. Simulation settings
```{r}
n_sim <- 100
n_total <- 100
r <- 60
true_a <- 2.5
true_b <- 1.5
true_p <- 1.2 # This parameter will be treated as known
```

### 4. Setup storage
```{r}
mle_results <- matrix(NA, nrow = n_sim, ncol = 3)
bayes_results <- matrix(NA, nrow = n_sim, ncol = 3)
colnames(mle_results) <- colnames(bayes_results) <- c("a", "b", "p")
```

### 5. Simulation Loop
```{r}
for (sim in 1:n_sim) {
  cat("Running simulation:", sim, "/", n_sim, "\n")
  set.seed(100 + sim)
  
  y_full <- sort(VGAM::rdagum(n = n_total, scale = true_b, shape1.a = true_a, shape2.p = true_p))
  failures <- y_full[1:r]
  y <- ifelse(failures <= 0, 1e-6, failures)
  N <- length(y)

  # --- MLE Estimation ---
  mle_fit <- try(optim(
      par = c(2, 2), fn = negloglik_dagum_p_fixed, data = y,
      p_fixed = true_p, method = "L-BFGS-B", lower = c(1e-5, 1e-5)
  ), silent = TRUE)
  
  if (!inherits(mle_fit, "try-error") && mle_fit$convergence == 0) {
    mle_results[sim, ] <- c(mle_fit$par, true_p)
  }

  # --- Bayesian Estimation ---
  jags_data <- list(y = y, N = N, p = true_p, zeros = rep(0, N))
  
  post_means <- try({
    model <- jags.model("dagum_model_p_fixed.txt", data = jags_data, n.chains = 2, n.adapt = 2000, quiet = TRUE)
    update(model, 2000)
    samples <- coda.samples(model, variable.names = c("a", "b"), n.iter = 5000)
    colMeans(as.matrix(samples))
  }, silent = TRUE)
  
  if (!inherits(post_means, "try-error")) {
    bayes_results[sim, ] <- c(post_means, true_p)
  }
}
```

### 6. Calculate and print results
```{r}
mle_results_clean <- na.omit(mle_results)
bayes_results_clean <- na.omit(bayes_results)

cat("\nNumber of successful MLE fits:", nrow(mle_results_clean), "/", n_sim, "\n")
cat("Number of successful Bayes fits:", nrow(bayes_results_clean), "/", n_sim, "\n\n")

compute_bias_mse <- function(estimates, true_vals) {
  bias <- colMeans(estimates) - true_vals
  mse <- colMeans((t(t(estimates) - true_vals))^2)
  return(list(bias = bias, mse = mse))
}

true_vals <- c("a" = true_a, "b" = true_b, "p" = true_p)

# We only calculate bias/mse for the estimated parameters 'a' and 'b'
mle_metrics <- compute_bias_mse(mle_results_clean[, 1:2], true_vals[1:2])
bayes_metrics <- compute_bias_mse(bayes_results_clean[, 1:2], true_vals[1:2])

cat("== Bias (for a, b) ==\nMLE:\n"); print(mle_metrics$bias)
cat("\nBayesian:\n"); print(bayes_metrics$bias)
cat("\n== MSE (for a, b) ==\nMLE:\n"); print(mle_metrics$mse)
cat("\nBayesian:\n"); print(bayes_metrics$mse)
```

